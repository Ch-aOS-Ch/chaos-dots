- name: "Set dotfiles repository path fact"
  set_fact:
    dotfiles_repo_path: "/home/{{ dotfile_item.user }}/.dotfiles/{{ dotfile_item.repo | urlsplit('path') | basename }}"

- name: "Cloning the repo: {{ dotfile_item.repo }}"
  ansible.builtin.git:
    repo: "{{ dotfile_item.repo }}"
    dest: "{{ dotfiles_repo_path }}"
    version: main
    force: true
  become: true
  become_user: "{{ dotfile_item.user }}"

- name: List files and directories in "{{ dotfile_item.repo }}"
  ansible.builtin.find:
    paths: "{{ dotfiles_repo_path }}"
    file_type: any
    recurse: false
    hidden: true
  register: dotfiles_dirs
  when: dotfiles_repo_path is defined

- name: Get list of all files in the path
  set_fact:
    dirs_files: "{{ dotfiles_dirs.files | map(attribute='path') | map('basename') | list }}"
  when: dotfiles_dirs.files is defined

- name: Load previous dotfiles state if exists
  ansible.builtin.slurp:
    path: "/home/{{ dotfile_item.user }}/.local/state/charonte/dotfiles_{{ dotfile_item.repo | urlsplit('path') | basename }}.yml"
  register: dotfiles_previous_state
  failed_when: false
  changed_when: false
  when: dotfile_item.manager | default('') == 'charonte'

- name: Parse previous state
  set_fact:
    prev_state: "{{ dotfiles_previous_state.content | b64decode | from_yaml | default({'applied': []}) }}"
  when: dotfile_item.manager | default('') == 'charonte'

- name: "Executing custom install_command"
  ansible.builtin.command:
    cmd: "{{ dotfile_item.install_command }}"
    chdir: "{{ dotfiles_repo_path }}"
  when:
    - dotfile_item.install_command is defined
    - dotfile_item.install_command | length > 0
    - dotfile_item.install_command is not in ['rm -rf /*', 'rm -rf / --no-preserve-root', 'rm -rf $HOME']
  become: true
  become_user: "{{ dotfile_item.user }}"

- name: "Applying the dotfiles with the {{ dotfile_item.manager | default('None') }} manager"
  ansible.builtin.command:
    cmd: |
      {% if dotfile_item.manager == 'stow' %}
      stow --target=/home/{{ dotfile_item.user }} --dir=. *
      {% elif dotfile_item.manager == 'yadm' %}
      echo "yadm not implemented yet, please use stow."
      {% endif %}
    chdir: "{{ dotfiles_repo_path }}"
  when:
    - dotfile_item.manager is defined
    - dotfile_item.manager | length > 0
    - dotfile_item.manager != "charonte"
  become: true
  become_user: "{{ dotfile_item.user }}"

- name: "Initialize new repo state list"
  set_fact:
    new_repo_state: []
  when: dotfile_item.manager | default('') == 'charonte'

- name: "Compute paths to remove"
  when: dotfile_item.manager | default('') == 'charonte'
  block:
    - name: "Initialize list of paths to remove"
      set_fact:
        paths_to_remove: []

    - name: "Iterate previous state to find all items to remove"
      vars:
        current_sources: "{{ dotfile_item.links | map(attribute='from') | list }}"
      when: item_to_remove.from not in current_sources
      loop: "{{ prev_state.applied | default([]) }}"
      loop_control:
        loop_var: item_to_remove
      set_fact:
        paths_to_remove: "{{ paths_to_remove + (item_to_remove.open | default(false) | ternary(item_to_remove.managed_files, [item_to_remove.path])) }}"

- name: Remove outdated dotfiles links
  ansible.builtin.file:
    path: "{{ item }}"
    state: absent
  loop: "{{ paths_to_remove | default([]) | unique }}"
  loop_control:
    label: "{{ item }}"
  become: true
  become_user: "{{ dotfile_item.user }}"
  when:
    - dotfile_item.manager | default('') == 'charonte'

- name: "Warn about missing source files for Ch-aronte manager"
  ansible.builtin.debug:
    msg: "WARNING: The source '{{ item.from }}' was not found in the repository '{{ dotfile_item.repo }}' and will be skipped."
  loop: "{{ dotfile_item.links | default([]) }}"
  loop_control:
    label: "{{ item.from }}"
  when:
    - dotfile_item.manager | default('') == 'charonte'
    - dirs_files is defined
    - item.from is defined
    - item.from not in dirs_files

- name: "Ensure parent directories exist for Ch-aronte links"
  ansible.builtin.file:
    path: "/home/{{ dotfile_item.user }}/{{ (item.to | default(item.from)) | dirname }}"
    state: directory
    mode: '0755'
  become: true
  become_user: "{{ dotfile_item.user }}"
  loop: "{{ dotfile_item.links | default([]) }}"
  loop_control:
    label: "{{ item.to | default(item.from) }}"
  when:
    - dotfile_item.manager | default('') == 'charonte'
    - dirs_files is defined
    - item.from is defined
    - item.from in dirs_files

- name: "Manage dotfile symlinks declaratively"
  ansible.builtin.include_tasks: process_charonte_item.yml
  loop: "{{ dotfile_item.links | default([]) }}"
  loop_control:
    label: "{{ item.to | default(item.from) }}"
  when:
    - dotfile_item.manager | default('') == 'charonte'
    - dirs_files is defined
    - item.from is defined
    - item.from in dirs_files

- name: "Verify if install.sh exists in repo path"
  ansible.builtin.stat:
    path: "{{ dotfiles_repo_path }}/install.sh"
  register: dotfiles_install_script_stat
  when:
    - dotfile_item.install_command is not defined
    - dotfile_item.manager is not defined
  become: true
  become_user: "{{ dotfile_item.user }}"

- name: "Execute install.sh in repo path"
  ansible.builtin.command:
    cmd: "bash install.sh"
    chdir: "{{ dotfiles_repo_path }}"
  when:
    - dotfiles_install_script_stat.stat is defined
    - dotfiles_install_script_stat.stat.exists
    - dotfile_item.manager is not defined
  become: true
  become_user: "{{ dotfile_item.user }}"

- name: "Ensure parent directory for dotfiles state exists"
  ansible.builtin.file:
    path: "/home/{{ dotfile_item.user }}/.local/state/charonte"
    state: directory
    mode: '0755'
  become: true
  become_user: "{{ dotfile_item.user }}"
  when:
    - dotfile_item.manager | default('') == 'charonte'

- name: Save new dotfiles state
  ansible.builtin.copy:
    dest: "/home/{{ dotfile_item.user }}/.local/state/charonte/dotfiles_{{ dotfile_item.repo | urlsplit('path') | basename }}.yml"
    content: "{{ {'applied': new_repo_state} | to_nice_yaml }}" # <~ I'll kill myself if someone sets this to to_yaml
    mode: "0644"
  become: true
  become_user: "{{ dotfile_item.user }}"
  when:
    - dotfile_item.manager | default('') == 'charonte'
